generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// ENUMS
enum Position {
  GOALKEEPER
  DEFENDER
  MIDFIELDER
  FORWARD
}

enum Role {
  PLAYER
  MANAGER
  ADMIN
}

enum MatchStatus {
  SCHEDULED
  ONGOING
  FINISHED
  CANCELLED
}

/// Team name is stricter now: only two sides allowed
enum TeamName {
  TEAM_A
  TEAM_B
}

/// MODELS

model User {
  id               Int      @id @default(autoincrement())
  firstName        String
  lastName         String
  dob              DateTime
  favoriteFoot     String
  favoritePosition Position
  phoneNumber      String   @unique
  email            String   @unique
  passwordHash     String
  role             Role     @default(PLAYER)    // new role field
  createdAt        DateTime @default(now())

  // Relations
  players Player[]            // a user can have multiple player profiles
  groups  Group[] @relation("UserGroups")
}

model Player {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  position  Position
  rating    Float    @default(0.0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  availability Availability[]
  matches      PlayerMatch[]
  ratings      Rating[]
  teams        Team[]       @relation("PlayerTeams")

  // Relation to User (many players per user)
  userId Int?
  user   User? @relation(fields: [userId], references: [id], onDelete: SetNull)
}

model Match {
  id         Int         @id @default(autoincrement())
  date       DateTime
  location   String
  duration   Int
  fee        Float
  createdBy  Int
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt

  capacity   Int         @default(10)
  status     MatchStatus @default(SCHEDULED)   // new status enum
  finalScore Json?                               // new finalScore as JSON; nullable

  // Relations
  players    PlayerMatch[]  // participation records
  teams      Team[]         // saved team assignments
  ratings    Rating[]

  /// Optional: you can add an FK constraint for createdBy if you want
  /// createdByUser User? @relation(fields:[createdBy], references:[id], onDelete: SetNull)
}

model PlayerMatch {
  id       Int    @id @default(autoincrement())
  playerId Int
  matchId  Int
  team     TeamName? // optionally reference TeamName enum for strictness

  match  Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([playerId, matchId]) // prevent duplicate participation
}

model Availability {
  id          Int      @id @default(autoincrement())
  playerId    Int
  matchDate   DateTime
  isAvailable Boolean  @default(true)

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)

  /// Optional: ensure one availability row per player+matchDate
  /// @@unique([playerId, matchDate])
}

model Group {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())

  users User[] @relation("UserGroups")
}

model Team {
  id        Int      @id @default(autoincrement())
  matchId   Int
  playerId  Int
  teamName  TeamName
  createdAt DateTime @default(now())

  // Relations (cascade deletion of team entries if match/player is deleted)
  match  Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player Player @relation("PlayerTeams", fields: [playerId], references: [id], onDelete: Cascade)

  /// Optional: if you want to prevent duplicate player entries for the same match+team:
  /// @@unique([matchId, playerId])
}

model Rating {
  id        Int      @id @default(autoincrement())
  playerId  Int
  matchId   Int
  score     Float
  comment   String?
  createdAt DateTime @default(now())

  player Player @relation(fields: [playerId], references: [id], onDelete: Cascade)
  match  Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([playerId, matchId]) // a player can only rate an opponent once per match
}

